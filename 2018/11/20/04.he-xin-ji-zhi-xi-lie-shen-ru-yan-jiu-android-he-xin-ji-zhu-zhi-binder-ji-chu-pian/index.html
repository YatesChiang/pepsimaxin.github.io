<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="深入钻研 Android 核心技术 之 Binder（基础篇）, Thinking in Android">
    <meta name="description" content="一、Binder 概述Binder 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>深入钻研 Android 核心技术 之 Binder（基础篇） | Thinking in Android</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <!--<div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Thinking in Android</span>
                </a>
            </div>-->
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>目录</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories/四大组件/" class="waves-effect waves-light">
            
            <i class="fa fa-cube"></i>
            
            <span>组件</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories/启动阶段/" class="waves-effect waves-light">
            
            <i class="fa fa-spinner"></i>
            
            <span>开机</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories/框架服务/" class="waves-effect waves-light">
            
            <i class="fa fa-superpowers"></i>
            
            <span>框架</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories/核心机制/" class="waves-effect waves-light">
            
            <i class="fa fa-link"></i>
            
            <span>机制</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories/性能优化/" class="waves-effect waves-light">
            
            <i class="fa fa-yelp"></i>
            
            <span>优化</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories/设计模式/" class="waves-effect waves-light">
            
            <i class="fa fa-envira"></i>
            
            <span>模式</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories/算法专栏/" class="waves-effect waves-light">
            
            <i class="fa fa-modx"></i>
            
            <span>算法</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories/技术储备/" class="waves-effect waves-light">
            
            <i class="fa fa-linode"></i>
            
            <span>拓展</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>作者</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories/技术细节/" class="waves-effect waves-light">
            
            <i class="fa fa-file-text"></i>
            
            <span>FAQ</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="检索博文"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Thinking in Android</div>
        <div class="logo-desc">
            
            Victory belongs to the most persevering.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                目录
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories/四大组件/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-cube"></i>
                
                组件
            </a>
        </li>
        
        <li>
            <a href="/categories/启动阶段/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-spinner"></i>
                
                开机
            </a>
        </li>
        
        <li>
            <a href="/categories/框架服务/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-superpowers"></i>
                
                框架
            </a>
        </li>
        
        <li>
            <a href="/categories/核心机制/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                机制
            </a>
        </li>
        
        <li>
            <a href="/categories/性能优化/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-yelp"></i>
                
                优化
            </a>
        </li>
        
        <li>
            <a href="/categories/设计模式/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-envira"></i>
                
                模式
            </a>
        </li>
        
        <li>
            <a href="/categories/算法专栏/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-modx"></i>
                
                算法
            </a>
        </li>
        
        <li>
            <a href="/categories/技术储备/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-linode"></i>
                
                拓展
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                作者
            </a>
        </li>
        
        <li>
            <a href="/categories/技术细节/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-file-text"></i>
                
                FAQ
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/Binder.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        深入钻研 Android 核心技术 之 Binder（基础篇）
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Binder/" target="_blank">
                                <span class="chip bg-color">Binder</span>
                            </a>
                        
                            <a href="/tags/核心技术/" target="_blank">
                                <span class="chip bg-color">核心技术</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/核心技术/" class="post-category" target="_blank">
                                核心技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>&nbsp;发布日期 :&nbsp;
                    2018-11-20
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>&nbsp;文章字数 :&nbsp;
                        5.6k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>&nbsp;阅读时长 :&nbsp;
                        20 分钟
                    </div>
                    
                
				
				
            </div>
        </div>
		<br>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="一、Binder-概述"><a href="#一、Binder-概述" class="headerlink" title="一、Binder 概述"></a>一、Binder 概述</h1><p>Binder 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。</p>
<h2 id="1-1-为什么要理解-Binder？"><a href="#1-1-为什么要理解-Binder？" class="headerlink" title="1.1 为什么要理解 Binder？"></a>1.1 为什么要理解 Binder？</h2><p>一般 Android 应用开发很少直接用到跨进程信通信（IPC），但如果你想知道：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔰 &nbsp;App 是如何启动并初始化的？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔰 &nbsp;Activity 的启动过程是怎样的？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔰 &nbsp;进程间是如何通信的？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔰 &nbsp;AIDL 的具体原理是什么？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔰 &nbsp;众多插件化框架的设计原理等等…</p>
<p>这些问题的背后都与 Binder 有莫大的关系，要弄懂上面这些问题，理解 Binder 通信机制是必须的。</p>
<p>我们知道 Android 应用程序是由 Activity、Service、Broadcast Receiver 和 Content Provide 四大组件中的一个或者多个组成的。有时这些组件运行在同一进程，有时运行在不同的进程。这些进程间的通信就依赖于 Binder IPC 机制。</p>
<p>不仅如此，Android 系统对应用层提供的各种服务如：ActivityManagerService、PackageManagerService 等都是基于 Binder IPC 机制来实现的。Binder 机制在 Android 中的位置非常重要，毫不夸张的说理解 Binder 是迈向 Android 高级工程的第一步。</p>
<h2 id="1-2-为什么选择-Binder"><a href="#1-2-为什么选择-Binder" class="headerlink" title="1.2 为什么选择 Binder ?"></a>1.2 为什么选择 Binder ?</h2><p>Android 系统是基于 Linux 内核的，Linux 已经提供了 <font color="#87CEFA">管道</font>、<font color="#87CEFA">消息队列</font>、<font color="#87CEFA">共享内存</font> 和 <font color="#87CEFA">Socket</font> 等 IPC 机制。</p>
<p>那为什么 Android 还要提供 <font color="#0000CD">Binder</font> 来实现 IPC 呢？主要是基于 <font color="#0000CD">性能</font>、<font color="#0000CD">稳定性</font> 和 <font color="#0000CD">安全性</font> 几方面的原因！</p>
<h3 id="1-2-1-性能"><a href="#1-2-1-性能" class="headerlink" title="1.2.1 性能"></a>1.2.1 性能</h3><p>首先说说性能上的优势。</p>
<p><font color="#FF0000">Socket</font>：作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。</p>
<p><font color="#FF0000">消息队列和管道</font>：采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。</p>
<p><font color="#FF0000">共享内存</font>：虽然无需拷贝，但控制复杂，难以使用。</p>
<p><font color="#FF0000">Binder</font>：只需要一次数据拷贝，性能上仅次于共享内存。</p>
<table>
<thead>
<tr>
<th>IPC机制</th>
<th>数据拷贝次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享内存</td>
<td>0</td>
</tr>
<tr>
<td>Binder</td>
<td>1</td>
</tr>
<tr>
<td>管道、消息队列、Socket</td>
<td>2</td>
</tr>
</tbody>
</table>
<h3 id="1-2-2-稳定性"><a href="#1-2-2-稳定性" class="headerlink" title="1.2.2 稳定性"></a>1.2.2 稳定性</h3><p>再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于共享内存的。</p>
<h3 id="1-2-3-安全性"><a href="#1-2-3-安全性" class="headerlink" title="1.2.3 安全性"></a>1.2.3 安全性</h3><p>Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。</p>
<p>首先传统的 IPC 接收方无法获得对方可靠的进程“用户ID/进程ID”（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APK 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。</p>
<p>传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。</p>
<p>其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<h1 id="二、传统-IPC-通信原理"><a href="#二、传统-IPC-通信原理" class="headerlink" title="二、传统 IPC 通信原理"></a>二、传统 IPC 通信原理</h1><p>了解 Linux IPC 相关的概念和原理有助于我们理解 Binder 通信原理。因此，在介绍 Binder 跨进程通信原理之前，我们先聊聊 Linux 系统下传统的进程间通信是如何实现。</p>
<h2 id="2-1-基础概念"><a href="#2-1-基础概念" class="headerlink" title="2.1 基础概念"></a>2.1 基础概念</h2><h3 id="2-1-1-进程隔离"><a href="#2-1-1-进程隔离" class="headerlink" title="2.1.1 进程隔离"></a>2.1.1 进程隔离</h3><p>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：<font color="#0000CD">进程间通信（IPC）</font>。</p>
<h3 id="2-1-2-进程空间"><a href="#2-1-2-进程空间" class="headerlink" title="2.1.2 进程空间"></a>2.1.2 进程空间</h3><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<h3 id="2-1-3-系统调用"><a href="#2-1-3-系统调用" class="headerlink" title="2.1.3 系统调用"></a>2.1.3 系统调用</h3><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助系统调用来实现。<font color="#FF0000">系统调用是用户空间访问内核空间的唯一方式</font>，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>
<p>当进程在执行用户自己的代码的时候，我们称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<h2 id="2-2-IPC-通信原理"><a href="#2-2-IPC-通信原理" class="headerlink" title="2.2 IPC 通信原理"></a>2.2 IPC 通信原理</h2><p>理解了上面的几个概念，我们再来看看传统的 IPC 方式中，进程之间是如何实现通信的。</p>
<p>通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 <font color="#FF0000">copyfromuser()</font> 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 <font color="#FF0000">copytouser()</font> 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。</p>
<p>我们来看下原理图：</p>
<center><img src="https://upload-images.jianshu.io/upload_images/3517194-635752d9992aeeca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传统 IPC 通信方式.png"></center>

<p>这种传统的 IPC 通信方式有两个问题：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ &nbsp;1、性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ &nbsp;2、接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小。</p>
<p>很明显，这两种做法不是浪费空间就是浪费时间。</p>
<h1 id="三、Binder-跨进程通信原理"><a href="#三、Binder-跨进程通信原理" class="headerlink" title="三、Binder 跨进程通信原理"></a>三、Binder 跨进程通信原理</h1><p>理解了 Linux IPC 相关概念和通信原理，接下来我们正式介绍下 Binder IPC 的原理。</p>
<h2 id="3-1-动态内核可加载模块"><a href="#3-1-动态内核可加载模块" class="headerlink" title="3.1 动态内核可加载模块"></a>3.1 动态内核可加载模块</h2><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？</p>
<p>这就得益于 Linux 的 <strong><font color="#FF0000">动态内核可加载模块</font></strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong><font color="#FFD39B">Binder 驱动</font></strong>（Binder Dirver）。</p>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。</p>
<p>这就涉及到我们接下来要说的 <strong><font color="#87CEFA">内存映射</font></strong> 的概念了。</p>
<h2 id="3-2-内存映射"><a href="#3-2-内存映射" class="headerlink" title="3.2 内存映射"></a>3.2 内存映射</h2><p>Binder IPC 机制中涉及到的内存映射通过 <strong><font color="#0000CD">mmap()</font></strong> 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h2 id="3-3-Binder-IPC-实现原理"><a href="#3-3-Binder-IPC-实现原理" class="headerlink" title="3.3 Binder IPC 实现原理"></a>3.3 Binder IPC 实现原理</h2><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。</p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。</p>
<p><strong><font color="#FFD39B">一次完整的 Binder IPC 通信过程通常是这样：</font></strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ &nbsp;1、首先 Binder 驱动在内核空间创建一个 <strong><font color="#87CEFA">数据接收缓存区</font></strong> ；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ &nbsp;2、接着在内核空间开辟一块内核缓存区，建立 <strong><font color="#87CEFA">内核缓存区</font></strong> 和 <strong><font color="#87CEFA">内核中数据接收缓存区</font></strong> 之间的映射关系，以及 <strong><font color="#87CEFA">内核中数据接收缓存区</font></strong> 和 <strong><font color="#87CEFA">接收进程用户空间地址</font></strong> 的映射关系；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ &nbsp;3、发送方进程通过系统调用 <strong><font color="#87CEFA">copyfromuser()</font></strong> 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</p>
<p>我们来看下原理图：</p>
<center><img src="https://upload-images.jianshu.io/upload_images/3517194-0c9748841ab26628.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/780" alt="Binder 通信原理.jpg"></center>

<h1 id="四、Binder-通信模型"><a href="#四、Binder-通信模型" class="headerlink" title="四、Binder 通信模型"></a>四、Binder 通信模型</h1><p>介绍完 Binder IPC 的底层通信原理，接下来我们看看实现层面是如何设计的。</p>
<p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为 <strong><font color="#87CEFA">客户端进程</font></strong>（Client）和 <strong><font color="#87CEFA">服务端进程</font></strong>（Server），由于进程隔离机制的存在，通信双方必然需要借助 <strong><font color="#87CEFA">Binder</font></strong> 来实现。</p>
<h2 id="4-1-Client-Server-ServiceManager-驱动"><a href="#4-1-Client-Server-ServiceManager-驱动" class="headerlink" title="4.1 Client/Server/ServiceManager/驱动"></a>4.1 Client/Server/ServiceManager/驱动</h2><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ &nbsp; Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ &nbsp; Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ &nbsp; Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p>如下原理图：</p>
<center><img src="https://upload-images.jianshu.io/upload_images/3517194-9b388624bd4db998.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/780" alt="通信模型.jpg"></center>

<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 DNS 域名服务器，域名服务器中保存了 <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> 对应的 ip 地址 10.249.23.13，然后通过这个 ip 地址才能找到 <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> 对应的服务器。</p>
<p>如下图所示：</p>
<center><img src="https://upload-images.jianshu.io/upload_images/3517194-b4d4af5e47697aa5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/780" alt="google.jpg"></center>

<h2 id="4-2-Android-Binder-设计与实现"><a href="#4-2-Android-Binder-设计与实现" class="headerlink" title="4.2 Android Binder 设计与实现"></a>4.2 Android Binder 设计与实现</h2><p><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Binder 设计与实现</a>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述。</p>
<h3 id="4-2-1-Binder-驱动"><a href="#4-2-1-Binder-驱动" class="headerlink" title="4.2.1 Binder 驱动"></a>4.2.1 Binder 驱动</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立、Binder 在进程之间的传递、Binder 引用计数管理、数据包在进程之间的传递和交互等一系列底层支持。 </p>
<h3 id="4-2-2-ServiceManager-与实名-Binder"><a href="#4-2-2-ServiceManager-与实名-Binder" class="headerlink" title="4.2.2 ServiceManager 与实名 Binder"></a>4.2.2 ServiceManager 与实名 Binder</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了有 IP 地址以外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！<font color="#87CEFA">Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋</font>。ServiceManager 和其他进程同样采用 Binder 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDERSETCONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体<font color="#87CEFA">（这就是那只预先造好的那只鸡）</font>。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>
<h3 id="4-2-3-Client-获得实名-Binder-的引用"><a href="#4-2-3-Client-获得实名-Binder-的引用" class="headerlink" title="4.2.3 Client 获得实名 Binder 的引用"></a>4.2.3 Client 获得实名 Binder 的引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
<h2 id="4-3-Binder-通信过程"><a href="#4-3-Binder-通信过程" class="headerlink" title="4.3 Binder 通信过程"></a>4.3 Binder 通信过程</h2><p>至此，我们大致能总结出 Binder 通信过程：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ 1、首先，一个进程使用 BINDERSETCONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ 2、Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ 3、Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</p>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<p>原理图：</p>
<center><img src="https://upload-images.jianshu.io/upload_images/3517194-1235f55b286716ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/780" alt="原理图.jpg"></center>

<h2 id="4-4-Binder-通信中的代理模式"><a href="#4-4-Binder-通信中的代理模式" class="headerlink" title="4.4 Binder 通信中的代理模式"></a>4.4 Binder 通信中的代理模式</h2><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程没法直接使用 B 进程中的 object。</p>
<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一模一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<p>原理图：</p>
<center><img src="https://upload-images.jianshu.io/upload_images/3517194-c870411b839705db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/780" alt="原理图.jpg"></center>

<h2 id="4-5-Binder-的完整定义"><a href="#4-5-Binder-的完整定义" class="headerlink" title="4.5 Binder 的完整定义"></a>4.5 Binder 的完整定义</h2><p>现在我们可以对 Binder 做个更加全面的定义了：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ 从进程间通信的角度看，Binder 是一种进程间通信的机制；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ 从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ 从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✨ 从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>&nbsp;📕 01. <a href="https://www.jianshu.com/p/062a6e4f5cbe" target="_blank" rel="noopener">关于Binder，作为应用开发者你需要知道的全部</a><br>&nbsp;📕 02. <a href="https://zhuanlan.zhihu.com/p/35519585" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a><br>&nbsp;📕 03. <a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Bander设计与实现 - 设计篇</a><br>&nbsp;📕 04. <a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="noopener">一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a></p>
<h1 id="索引链接"><a href="#索引链接" class="headerlink" title="索引链接"></a>索引链接</h1><p>推荐跳转：<a href="https://superandroid.pro/2019/12/31/%E3%80%8AThinking%20in%20Android%E3%80%8B%20--%2001.%20%E5%8D%9A%E5%AE%A2%E7%B4%A2%E5%BC%95/">博客索引（Android 9.0）</a></p>

            </div>
            <hr>

            

            <!--<link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>-->

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="https://superandroid.pro" class="b-link-green">Thinking in Android</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2018/11/20/04.he-xin-ji-zhi-xi-lie-shen-ru-yan-jiu-android-he-xin-ji-zhu-zhi-binder-ji-chu-pian/" class="b-link-green">深入钻研 Android 核心技术 之 Binder（基础篇）</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC8zNzY5OS8xNDIzMA">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    <!--

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6 overflow-policy" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2018/12/01/01.xi-tong-qi-dong-jie-duan-android-xi-tong-qi-dong-pian-shen-ru-zuan-yan-android-qi-dong-jie-duan-zhi-init/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/系统启动-02.jpg" class="responsive-img" alt="深入钻研 Android 启动阶段 之 init">
                        
                        <span class="card-title">深入钻研 Android 启动阶段 之 init</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 🍀 Android 启动阶段系列🍀 🍀 🍀 🍀 </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2018-12-01
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/系统启动/" class="post-category" target="_blank">
                                    系统启动
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/启动阶段/" target="_blank">
                        <span class="chip bg-color">启动阶段</span>
                    </a>
                    
                    <a href="/tags/init/" target="_blank">
                        <span class="chip bg-color">init</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6 overflow-policy" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2018/11/10/04.he-xin-ji-zhi-xi-lie-shen-ru-zuan-yan-android-he-xin-ji-zhu-zhi-jni/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/JNI.jpg" class="responsive-img" alt="深入钻研 Android 核心技术 之 JNI">
                        
                        <span class="card-title">深入钻研 Android 核心技术 之 JNI</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">1. 开篇1.1 核心源码


关键类
路径




MediaScanner.java
frameworks/base/media/java/android/media/MediaScanner.java


android_media_</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-11-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/核心技术/" class="post-category" target="_blank">
                                    核心技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/核心技术/" target="_blank">
                        <span class="chip bg-color">核心技术</span>
                    </a>
                    
                    <a href="/tags/JNI/" target="_blank">
                        <span class="chip bg-color">JNI</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>-->
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Thinking in Android<br />'
            + '作者: Marco<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
		    &copy; 2018 - 2019&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In-depth analysis of Android system source code &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-graduation-cap" aria-hidden="true"></i>&nbsp;&nbsp;By Marco<br>
            
			
		</div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/pepsimaxin/pepsimaxin.github.io" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:pepsimaxin@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=516749232" class="tooltipped" data-tooltip="QQ联系我: 516749232" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;检索博文</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的技术关键字" class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->





</body>
</html>