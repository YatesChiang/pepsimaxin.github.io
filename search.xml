<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客索引（Android 9.0）</title>
      <link href="/2020/01/01/00.thinking-in-android-01.bo-ke-suo-yin/"/>
      <url>/2020/01/01/00.thinking-in-android-01.bo-ke-suo-yin/</url>
      
        <content type="html"><![CDATA[<h4 id="Thinking-in-Android-–-“启动阶段”"><a href="#Thinking-in-Android-–-“启动阶段”" class="headerlink" title="Thinking in Android – “启动阶段”"></a><center>Thinking in Android – “启动阶段”</center></h4><p><br></p><table><thead><tr><th style="text-align:center"><strong><font color="#EE2C2C" size="3">【启动阶段】</font></strong></th><th style="text-align:center"><strong><font color="#0000FF" size="3">【相关文章】</font></strong></th><th style="text-align:center"><strong><font color="#9932CC" size="3">状态</font></strong></th><th style="text-align:center"><strong>源码版本</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong><font color="#FF7F00" size="3">init</font></strong></td><td style="text-align:center"><a href="https://superandroid.pro/2018/10/03/A_01.%20Android%20%E6%A1%86%E6%9E%B6%E6%9C%8D%E5%8A%A1%E7%AF%87%20--%20%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%20Android%20%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%20%E4%B9%8B%20init/">深入研究 Android 启动阶段 之 init</a></td><td style="text-align:center"><font color="#FF0000" size="3">完结</font></td><td style="text-align:center"><strong>9.0</strong></td></tr><tr><td style="text-align:center"><strong><font color="#FF7F00" size="3">zygote</font></strong></td><td style="text-align:center"><a href="https://superandroid.pro/2018/10/10/A_03.%20Android%20%E6%A1%86%E6%9E%B6%E6%9C%8D%E5%8A%A1%E7%AF%87%20--%20%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%20Android%20%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%20%E4%B9%8B%20zygote/">深入研究 Android 启动阶段 之 zygote</a></td><td style="text-align:center"><font color="#FF0000" size="3">完结</font></td><td style="text-align:center"><strong>9.0</strong></td></tr><tr><td style="text-align:center"><strong><font color="#FF7F00" size="3">systemserver</font></strong></td><td style="text-align:center"><a href="https://superandroid.pro/2018/10/18/A_02.%20Android%20%E6%A1%86%E6%9E%B6%E6%9C%8D%E5%8A%A1%E7%AF%87%20--%20%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%20Android%20%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%20%E4%B9%8B%20systemServer/">深入研究 Android 启动阶段 之 systemserver</a></td><td style="text-align:center"><font color="#FF0000" size="3">完结</font></td><td style="text-align:center"><strong>9.0</strong></td></tr><tr><td style="text-align:center"><strong><font color="#FF7F00" size="3">Launcher</font></strong></td><td style="text-align:center"><a href="https://superandroid.pro/2018/10/26/A_04.%20Android%20%E6%A1%86%E6%9E%B6%E6%9C%8D%E5%8A%A1%E7%AF%87%20--%20%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%20Android%20%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%20%E4%B9%8B%20Launcher/">深入研究 Android 启动阶段 之 Launcher 启动及加载流程</a></td><td style="text-align:center"><font color="#FF0000" size="3">完结</font></td><td style="text-align:center"><strong>9.0</strong></td></tr></tbody></table><p><br></p><h4 id="Thinking-in-Android-–-“算法专栏”"><a href="#Thinking-in-Android-–-“算法专栏”" class="headerlink" title="Thinking in Android – “算法专栏”"></a><center>Thinking in Android – “算法专栏”</center></h4><p><br></p><table><thead><tr><th style="text-align:center"><strong><font color="#EE2C2C" size="3">【算法专栏】</font></strong></th><th style="text-align:center"><strong><font color="#0000FF" size="3">【相关文章】</font></strong></th><th style="text-align:center"><strong><font color="#9932CC" size="3">状态</font></strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong><font color="#FF7F00" size="3">算法复杂度</font></strong></td><td style="text-align:center"><a href="https://superandroid.pro/2018/12/25/K_01.%20Android%20%E7%A8%8B%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AF%87%20--%20%E8%B0%88%E8%B0%88%20%E2%80%9C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E2%80%9D/">谈谈算法中的 “时间复杂度”</a></td><td style="text-align:center">&nbsp;&nbsp;&nbsp;&nbsp;<font color="#FF0000" size="3">完结</font></td></tr></tbody></table><p><br></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架服务 </tag>
            
            <tag> 通信机制 </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源收藏</title>
      <link href="/2020/01/01/00.thinking-in-android-02.zi-yuan-shou-cang/"/>
      <url>/2020/01/01/00.thinking-in-android-02.zi-yuan-shou-cang/</url>
      
        <content type="html"><![CDATA[<h4 id="Android-官方"><a href="#Android-官方" class="headerlink" title="Android 官方"></a><center>Android 官方</center></h4><p><br></p><style>table th:first-of-type {    width: 490px;}</style><table><thead><tr><th style="text-align:center"><strong><a href="https://source.android.com/" target="_blank" rel="noopener">AOSP</a></strong></th><th style="text-align:center"><strong><a href="https://developer.android.google.cn/index.html" target="_blank" rel="noopener">Android Developers</a></strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong><a href="http://www.android-studio.org/" target="_blank" rel="noopener">Android Studio - 中文社区</a></strong></td><td style="text-align:center"><strong><a href="http://androidxref.com/" target="_blank" rel="noopener">Android 源码 - 在线检索</a></strong></td></tr></tbody></table><p><br></p><hr><h4 id="Android-知名博主"><a href="#Android-知名博主" class="headerlink" title="Android 知名博主"></a><center>Android 知名博主</center></h4><p><br></p><style>table th:first-of-type {    width: 490px;}</style><table><thead><tr><th style="text-align:center"><strong><a href="http://gityuan.com/" target="_blank" rel="noopener">Gityuan</a></strong></th><th style="text-align:center"><strong><a href="https://blog.csdn.net/innost?viewmode=contents" target="_blank" rel="noopener">Innost 的专栏</a></strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">老罗的 Android 之旅</a></strong></td><td style="text-align:center"><strong><a href="http://blog.csdn.net/guolin_blog/" target="_blank" rel="noopener">郭霖</a></strong></td></tr><tr><td style="text-align:center"><strong><a href="http://liuwangshu.cn/system/" target="_blank" rel="noopener">刘望舒</a></strong></td><td style="text-align:center"><strong><a href="https://me.csdn.net/cjpx00008" target="_blank" rel="noopener">香辣牛肉面</a></strong></td></tr><tr><td style="text-align:center"><strong><a href="https://www.jianshu.com/u/77699cd41b28" target="_blank" rel="noopener">i校长</a></strong></td><td style="text-align:center"><strong><a href="http://guoyangard.cn/" target="_blank" rel="noopener">ArrayBy</a></strong></td></tr><tr><td style="text-align:center"><strong><a href="http://blog.csdn.net/Android_Tutor/" target="_blank" rel="noopener">魏祝林</a></strong></td><td style="text-align:center"><strong><a href="https://www.jianshu.com/u/3b1099674c2c" target="_blank" rel="noopener">看书的小蜗牛</a></strong></td></tr><tr><td style="text-align:center"><strong><a href="https://blog.csdn.net/Gaugamela/article/details/78655546" target="_blank" rel="noopener">ZhangJianIsAStark</a></strong></td><td style="text-align:center"><strong><a href="https://www.jianshu.com/u/8b9c629f69dd" target="_blank" rel="noopener">隔壁老李头</a></strong></td></tr></tbody></table><p><br></p><hr><h4 id="Android-精品技术贴"><a href="#Android-精品技术贴" class="headerlink" title="Android 精品技术贴"></a><center>Android 精品技术贴</center></h4><p><br></p><style>table th:first-of-type {    width: 490px;}</style><table><thead><tr><th style="text-align:center"><strong><a href="https://www.cnblogs.com/vincent0519/p/6060114.html" target="_blank" rel="noopener">Android 性能优化浅谈</a></strong></th><th style="text-align:center"><strong><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0526/7973.html" target="_blank" rel="noopener">31个 Android 开发工具</a></strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong><a href="https://meedamian.com/post/deuglifying-android-studio/" target="_blank" rel="noopener">Making Android Studio pretty</a></strong></td><td style="text-align:center"><strong><a href="https://blog.csdn.net/QQxiaoqiang1573/article/details/72903237" target="_blank" rel="noopener">Android Studio 导入整个 Android 系统源码</a></strong></td></tr><tr><td style="text-align:center"><strong><a href="https://github.com/BolexLiu/AutoEx" target="_blank" rel="noopener">帮助 Android 开发者，自动寻找 Stack Overflow 的解决方案</a></strong></td><td style="text-align:center"><strong><a href="https://androidweekly.cn/" target="_blank" rel="noopener">Android 开发技术周报</a></strong></td></tr></tbody></table><p><br></p><p><br></p><hr><h4 id="Linux-专区"><a href="#Linux-专区" class="headerlink" title="Linux 专区"></a><center>Linux 专区</center></h4><p><br></p><style>table th:first-of-type {    width: 490px;}</style><table><thead><tr><th style="text-align:center"><strong><a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的 Linux 私房菜</a></strong></th><th style="text-align:center"><strong><a href="https://blog.csdn.net/u010746357/article/details/81813739" target="_blank" rel="noopener">Ubuntu 频繁卡死解决</a></strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong><a href="https://www.cnblogs.com/wmr95/p/7574615.html" target="_blank" rel="noopener">Ubuntu16.04 安装 Teamviewer</a></strong></td><td style="text-align:center"><strong>… …</strong></td></tr></tbody></table><p><br></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 官方资料 </tag>
            
            <tag> 优秀博主 </tag>
            
            <tag> 干货资源 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客日志</title>
      <link href="/2020/01/01/00.thinking-in-android-03.xiu-gai-ri-zhi/"/>
      <url>/2020/01/01/00.thinking-in-android-03.xiu-gai-ri-zhi/</url>
      
        <content type="html"><![CDATA[<style>table th:first-of-type {    width: 200px;}</style><h4 id="Thinking-in-Android-–-“新增”"><a href="#Thinking-in-Android-–-“新增”" class="headerlink" title="Thinking in Android – “新增”"></a><center>Thinking in Android – “新增”</center></h4><p><br></p><table><thead><tr><th style="text-align:center">日期</th><th style="text-align:center">修订博文</th><th style="text-align:center">当前版本</th></tr></thead><tbody><tr><td style="text-align:center">2010.03.01</td><td style="text-align:center"><font color="#87CEEB" size="3"> 《谈谈算法中的 “时间复杂度》” </font></td><td style="text-align:center"><font color="#87CEEB" size="3">v_1.0</font></td></tr></tbody></table><p><br></p><h4 id="Thinking-in-Android-–-“修订”"><a href="#Thinking-in-Android-–-“修订”" class="headerlink" title="Thinking in Android – “修订”"></a><center>Thinking in Android – “修订”</center></h4><p><br></p><table><thead><tr><th style="text-align:center">日期</th><th style="text-align:center">修订博文</th><th style="text-align:center">修订次数</th></tr></thead><tbody><tr><td style="text-align:center">2019.02.02</td><td style="text-align:center"><font color="#87CEEB" size="3"> 《谈谈算法中的 “时间复杂度》” </font></td><td style="text-align:center">1</td></tr></tbody></table><p><br></p><h4 id="Thinking-in-Android-–-“优化”"><a href="#Thinking-in-Android-–-“优化”" class="headerlink" title="Thinking in Android – “优化”"></a><center>Thinking in Android – “优化”</center></h4><p><br></p><table><thead><tr><th style="text-align:center">日期</th><th style="text-align:center">修改记录 </th></tr></thead><tbody><tr><td style="text-align:center">2019.04.14</td><td style="text-align:center"><font color="#87CEEB" size="3">重构博客布局及文章</font></td></tr><tr><td style="text-align:center">2019.01.24</td><td style="text-align:center"><font color="#87CEEB" size="3">优化布局，导航栏新增项</font></td></tr><tr><td style="text-align:center">2019.01.07</td><td style="text-align:center"><font color="#87CEEB" size="3">Blog计划更新，部分细节优化</font></td></tr><tr><td style="text-align:center">2019.01.02</td><td style="text-align:center"><font color="#87CEEB" size="3">局部修改UI细节</font></td></tr><tr><td style="text-align:center">2018.12.29</td><td style="text-align:center"><font color="#87CEEB" size="3">新增 Links 页，局部修改UI细节</font></td></tr><tr><td style="text-align:center">2018.12.13</td><td style="text-align:center"><font color="#87CEEB" size="3">关于作者页面 – 主题优化</font></td></tr><tr><td style="text-align:center">2018.12.11</td><td style="text-align:center"><font color="#87CEEB" size="3">优化 Blog – 标签页</font></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><font color="#87CEEB" size="3">优化 Blog – 目录页</font></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><font color="#87CEEB" size="3">新增 Blog –   时间源追溯</font></td></tr><tr><td style="text-align:center">2018.12.03</td><td style="text-align:center"><font color="#87CEEB" size="3">Blog 主题改版 – 卡片式风格</font></td></tr><tr><td style="text-align:center">2018.07.01</td><td style="text-align:center"><font color="#87CEEB" size="3">《Thinking in Android》博客启程</font></td></tr></tbody></table><p><br></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客优化 </tag>
            
            <tag> 修订记录 </tag>
            
            <tag> 方向规划 </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈算法中的 “时间复杂度”</title>
      <link href="/2019/03/01/suan-fa-zhuan-lan-tan-tan-shi-jian-fu-za-du/"/>
      <url>/2019/03/01/suan-fa-zhuan-lan-tan-tan-shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<h2 id="1、算法效率"><a href="#1、算法效率" class="headerlink" title="1、算法效率"></a>1、算法效率</h2><p>虽然随着计算机硬件的迭代更新，运算处理的性能越来越强，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到 <strong><font color="#9932CC">“算法的效率”</font></strong>。</p><p>衡量算法的 <strong>“好坏”</strong> 和 <strong>“效率”</strong> 主要由以下两个指标（复杂度）来评估：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><font color="#FF0000">时间复杂度（运行时间）：</font></strong>评估执行程序所需的时间，可以估算出程序对处理器的使用程度。<strong><font color="#0000CD">（本篇博文我们重点探讨时间复杂度）</font></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><font color="#FF0000">空间复杂度（占用空间）：</font></strong>评估执行程序所需的存储空间，可以估算出程序对计算机内存的使用程度。</p><h2 id="2、算法事例"><a href="#2、算法事例" class="headerlink" title="2、算法事例"></a>2、算法事例</h2><p>我们通过几个场景引出时间复杂度的概念，以及常见的几种时间复杂度，最后再总结比较它们的优劣！</p><blockquote><p><strong>场景一</strong></p></blockquote><p><strong><font color="#FFA500">生活场景：</font></strong> <strong>你买了一箱“牛栏山二锅头”（16瓶），2 天喝一瓶，全部喝完需要几天？</strong></p><p>这是一道很简单的算术问题，2 ✖ 16 = 32 天。那如果一箱有 n 瓶，则需要 2 ✖ n = 2n 天，如果我们用一个函数来表达这个相对时间，可以记作 <strong><font color="#FF0000">T(n) = 2n</font></strong> 。</p><p><strong><font color="#FFA500">代码场景：</font></strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 执行次数是线性的</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"喝一瓶酒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待一天"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p><strong>场景二</strong></p></blockquote><p><strong><font color="#FFA500">生活场景：</font></strong> <strong>你又买了一箱“牛栏山二锅头”（16瓶），5 天为一个周期，每次喝剩下酒的一半，于是第一次喝 8 瓶，第二次喝 4 瓶，那么喝到最后一瓶需要几天？</strong></p><p>这个问题也很简单，16/2 = 8，8/2 = 4，4/2 = 2，2/2 = 1（还剩一瓶），这不就是对数函数吗？以 2 为底数，16为真数，得到的对数就是我们需要的答案，我们可以简写为：5log16。如果一箱有 n 瓶，则需要 5logn 天，如果我们用一个函数来表达这个相对时间，可以记作 <strong><font color="#FF0000">T(n) = 5logn</font></strong> 。</p><p><strong><font color="#FFA500">代码场景：</font></strong></p><pre class=" language-java"><code class="language-java">   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"喝一瓶酒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待一天"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待一天"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待一天"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待一天"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>场景三</strong></p></blockquote><p><strong><font color="#FFA500">生活场景：</font></strong> <strong>酒喝多了，买了一瓶枸杞，3 天喝一瓶，请问喝完枸杞要几天？</strong></p><p>是的，你没听错，我确实是问你喝完枸杞要多久？答案很简单：3天！如果我们用一个函数来表达这个相对时间，可以记作：<strong><font color="#FF0000">T(n) = 3</font></strong> 。</p><p><strong><font color="#FFA500">代码场景：</font></strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">drink</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"喝一瓶枸杞"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待一天"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待一天"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>场景四</strong></p></blockquote><p><strong><font color="#FFA500">生活场景：</font></strong> <strong>酒瘾难戒，又买了一箱好酒（6瓶），但是又不能多喝，于是第一瓶喝了1天，第二瓶喝了2天，第三瓶喝了3天，这样下去全部喝完需要几天？</strong></p><p>不用我说，其实这就是一个 1 + 2 + 3 … + 6 的算术问题，我们知道有个公式：6(6+1)/2 = 21 天，那如果有 n 瓶，就需要 n(n+1)/2 天，如果我们用一个函数来表达这个相对时间，可以记作 <strong><font color="#FF0000">T(n) = n²/2 + n/2</font></strong> 。</p><p><strong><font color="#FFA500">代码场景：</font></strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">drink</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待一天"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"喝一瓶酒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3、渐进时间复杂度"><a href="#3、渐进时间复杂度" class="headerlink" title="3、渐进时间复杂度"></a>3、渐进时间复杂度</h2><p>有了基本操作执行次数的函数 T(n)，是否就可以分析和比较一段代码的运行时间了呢？还是有一定的困难。比如算法 A 的相对时间是 <strong><font color="#0000CD">T(n) = 100n</font></strong> ，算法 B 的相对时间是 <strong><font color="#0000CD">T(n) = 5n²</font></strong> ，这两个到底谁的运行时间更长一些？<strong><font color="#0000CD">这就要看 n 的取值了！</font></strong></p><p>所以，这时候有了 <strong><font color="#FF0000">“渐进时间复杂度”</font></strong>（asymptotic time complectiy）的概念。</p><blockquote><p><strong><font color="#8470FF">我们看看官方的定义：</font></strong><br>若存在函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数。记作 T(n)= O(f(n))，称 O(f(n)) 为算法的 <strong><font color="#FF0000">“渐进时间复杂度”</font></strong>，简称 <strong><font color="#FF0000">“时间复杂度”</font></strong>。渐进时间复杂度用大写 O 来表示，所以也被称为 <strong><font color="#FF0000">“大O表示法”</font></strong>。</p></blockquote><h2 id="4、推导原则"><a href="#4、推导原则" class="headerlink" title="4、推导原则"></a>4、推导原则</h2><p><strong><font color="#FF0000">如何推导出时间复杂度呢？有如下几个原则：</font></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚫&nbsp;1、如果运行时间是常数量级，用常数 1 表示；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚫&nbsp;2、只保留时间函数中的最高阶项；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚫&nbsp;3、如果最高阶项存在，则省去最高阶项前面的系数。</p><h2 id="5、事例再分析"><a href="#5、事例再分析" class="headerlink" title="5、事例再分析"></a>5、事例再分析</h2><blockquote><p><strong>场景一</strong></p></blockquote><p>相对时间：<strong><font color="#0000FF">T(n) = 2n</font></strong> ，根据推导原则 3：最高阶数为 2n ，省去系数 2 ，转换后的时间复杂度为：<strong><font color="#FF0000">T(n) = O(n)</font></strong> 。</p><blockquote><p><strong>场景二</strong></p></blockquote><p>相对时间：<strong><font color="#0000FF">T(n) = 5logn</font></strong> ，根据推导原则 3：最高阶数为 5logn ，省去系数 5 ，转换后的时间复杂度为：<strong><font color="#FF0000">T(n) = O(logn)</font></strong> 。</p><blockquote><p><strong>场景三</strong></p></blockquote><p>相对时间：<strong><font color="#0000FF">T(n) = 3</font></strong> ，根据推导原则 1：只有常数量级 ，用常数 1 表示 ，转换后的时间复杂度为：<strong><font color="#FF0000">T(n) = O(1)</font></strong> 。</p><blockquote><p><strong>场景四</strong></p></blockquote><p>相对时间：<strong><font color="#0000FF">T(n) = n²/2 + n/2</font></strong> ，根据推导原则 2：最高阶数为 n²/2 ，省去系数 0.5 ，转换后的时间复杂度为：<strong><font color="#FF0000">T(n) = O(n²)</font></strong> 。</p><p>这四种时间复杂度究竟谁用时更长，谁节省时间呢？<strong><font color="#FF00FF">O(1) &lt; O(logn) &lt; O(n) &lt; O(n²)</font></strong></p><h2 id="6、其他常见复杂度"><a href="#6、其他常见复杂度" class="headerlink" title="6、其他常见复杂度"></a>6、其他常见复杂度</h2><p>除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度：</p><table><thead><tr><th style="text-align:center">f(n)</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">阶</th></tr></thead><tbody><tr><td style="text-align:center">nlogn</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">nlogn 阶</td></tr><tr><td style="text-align:center">n³</td><td style="text-align:center">O(n³)</td><td style="text-align:center">立方阶</td></tr><tr><td style="text-align:center">2ⁿ</td><td style="text-align:center">O(2ⁿ)</td><td style="text-align:center">指数阶</td></tr><tr><td style="text-align:center">n!</td><td style="text-align:center">O(n!)</td><td style="text-align:center">阶乘阶</td></tr><tr><td style="text-align:center">(√n)</td><td style="text-align:center">O(√n)</td><td style="text-align:center">平方根阶</td></tr></tbody></table><h2 id="7、复杂度比较"><a href="#7、复杂度比较" class="headerlink" title="7、复杂度比较"></a>7、复杂度比较</h2><table><thead><tr><th style="text-align:center">n</th><th style="text-align:center">logn</th><th style="text-align:center">√n</th><th style="text-align:center">nlogn</th><th style="text-align:center">n²</th><th style="text-align:center">2ⁿ</th><th style="text-align:center">n!</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">10</td><td style="text-align:center">25</td><td style="text-align:center">32</td><td style="text-align:center">120</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">30</td><td style="text-align:center">100</td><td style="text-align:center">1024</td><td style="text-align:center">3628800</td></tr><tr><td style="text-align:center">50</td><td style="text-align:center">5</td><td style="text-align:center">7</td><td style="text-align:center">250</td><td style="text-align:center">2500</td><td style="text-align:center">约10^15</td><td style="text-align:center">约3.0*10^64</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">6</td><td style="text-align:center">10</td><td style="text-align:center">600</td><td style="text-align:center">10000</td><td style="text-align:center">约10^30</td><td style="text-align:center">约9.3*10^157</td></tr><tr><td style="text-align:center">1000</td><td style="text-align:center">9</td><td style="text-align:center">31</td><td style="text-align:center">9000</td><td style="text-align:center">1000 000</td><td style="text-align:center">约10^300</td><td style="text-align:center">约4.0*10^2567</td></tr></tbody></table><p><br></p><p>从上表可以看出，O(n)、O(logn)、O(√n)、O(nlogn) 随着 n 的增加，复杂度提升不大，因此这些复杂度属于效率比较高的算法，反观 O(2ⁿ) 和 O(n!) 当 n 增加到 50 时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。</p><p>这些时间复杂度究竟谁用时更长，谁节省时间呢？</p><p><strong><font color="#FF00FF">O(1) &lt; O(logn) &lt; O(√n) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)</font></strong></p><h2 id="8、再举一例"><a href="#8、再举一例" class="headerlink" title="8、再举一例"></a>8、再举一例</h2><p><strong><font color="#FF0000">【疑问】：现在计算机硬件性能越来越强，算法真的体验那么明显吗？算法时间复杂度真的需要那么重视吗？</font></strong></p><p>我相信你肯定存在这样的疑问，虽然我们知道算法这个东西是很重要的，但是我们平常可能接触不多，很多时候计算机的性能已经能满足我们的需求，但是我还是要举个例子让你更直观的看到不同算法之间的巨大差异！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#FF00FF">算法 A 的相对时间规模是 T(n) = 100n，时间复杂度是 O(n)，算法 A 运行在老旧电脑上。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#FF00FF">算法 B 的相对时间规模是 T(n) = 5n²，时间复杂度是 O(n²)，算法 B 运行在某台超级计算机上，运行速度是老旧电脑的 100 倍。</font></p><p>当随着 n 的增大，我们通过表格看看 T(n) 的变化：</p><table><thead><tr><th style="text-align:center">n</th><th style="text-align:center">T(n) = 100n ✖ 100</th><th style="text-align:center">T(n) = 5n²</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">10000</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">50000</td><td style="text-align:center">125</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">10 0000</td><td style="text-align:center">500</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">100 0000</td><td style="text-align:center">50000</td></tr><tr><td style="text-align:center">1000</td><td style="text-align:center">1000 0000</td><td style="text-align:center">500 0000</td></tr><tr><td style="text-align:center">2000</td><td style="text-align:center"><font color="#FF0000">2000 0000</font></td><td style="text-align:center"><font color="#FF0000">2000 0000</font></td></tr><tr><td style="text-align:center">10000</td><td style="text-align:center">1 0000 0000</td><td style="text-align:center">5 0000 0000</td></tr><tr><td style="text-align:center">100000</td><td style="text-align:center">10 0000 0000</td><td style="text-align:center">500 0000 0000</td></tr><tr><td style="text-align:center">1000000</td><td style="text-align:center">100 0000 0000</td><td style="text-align:center">50000 0000 0000</td></tr></tbody></table><p><br></p><p>从表格中可以看出，当 n 的值很小的时候，算法 A 的运行用时要远大于算法 B；当 n 的值达到 1000 左右，算法 A 和算法 B 的运行时间已经接近；当 n 的值达到 2000 左右，算法 A 和 算法 B 的运行时间一致；当 n 的值越来越大，达到十万、百万时，算法 A 的优势开始显现，算法 B 则越来越慢，差距越来越明显。这就是不同时间复杂度带来的差距，即便你的计算机很牛X！</p><p><br></p><p><strong><font color="#FF00FF" size="5">参考博客</font></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://blog.csdn.net/qq_41523096/article/details/82142747" target="_blank" rel="noopener">一套图 搞懂“时间复杂度”</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
